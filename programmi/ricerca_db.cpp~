//compile with: g++ ricerca_db.cpp -o ricerca_db -lpqxx -lpq

#include <iostream>
#include <pqxx/pqxx> 
#include <vector>
#include <ctime>
#include "rast.cpp"
#include <algorithm>
#include "linea.cpp"
#include "open_image.cpp"



using namespace std;
using namespace pqxx;

//bitmask
vector<float> bitmask_pesi;
vector<int> bitmask;

vector<int> npunti_immagini;

//indici_immagini[i] = id dell'iesima immagine
vector<int> indici_immagini;

struct id_iml{
	int id_immagine;
	int id_linea;
	float peso;
};

//elevamento a potenza
int pow(int base, int esponente) {
	int result = base;
	for(int i=0; i<esponente; ++i) {
		result = result * base;
	}
	
	return result;
}


//torna gli indici dei vicini di una line con i parametri contenuti in v
/*
list<int> get_indici(int *v){
	//vettore che andra a contenere gli indici che sto cercando
	list<int> indici;
	int v_app[6];
	for(int i=0; i<6; ++i) {
		v_app[i] = intervallo_min(v[i]);
	}
	
	//elemento corrente
	int current = 5;
	
	//genero tutti gli indici di distanza 1
	while(!raggiunto_max(v, v_app)){
		linea l(v_app[0], v_app[1], v_app[2], v_app[3], v_app[4], v_app[5]);
		if((v_app[current]<=intervallo_max(v[current]))){
			indici.push_front(l.get_indice());
			v_app[current]++;
			//l.print();
		}
		else {			
			do {
				v_app[current] = intervallo_min(v[current]);
				--current;
				
			}while((v_app[current]>=intervallo_max(v[current]) && current>=0));
			if(current>=0) {
				v_app[current]++;
				
			}
			current=5;
			
		}
	}
	linea l(v_app[0], v_app[1], v_app[2], v_app[3], v_app[4], v_app[5]);
	indici.push_front(l.get_indice());
	v_app[current]++;
	
	return indici;
}


void ricerca(linea l, const vector<list<linea> > &linee) {
	int v_linea[6] = {l.get_r(), l.get_g(), l.get_b(), l.get_rp(), l.get_gp(), l.get_bp()};
	list<int> indici = get_indici(v_linea);
	
	//stampo tutte le dimensioni delle  liste vicine della linea in input
	for(list<int>::iterator it=indici.begin(); it!=indici.end(); ++it) {
		list<linea> lista = linee[*it];
		if(lista.size()>0) {
			linea l = *lista.begin();
			cout<<lista.size()<<" elementi:";
			l.print();
		}
			
		/*
		for(list<linea>::iterator ij=lista.begin(); ij!=lista.end(); ++ij) {
			linea l = *ij;
			l.print();
		}*/
	/*
	}
	
}*/


int get_pindex(int r, int g, int b) {
	int indice = r + g * 16 + b * pow(16, 2);
	
	return indice;
}

void pindex_to_rgb(int pindex, int &r, int &g, int &b) {
	if(pindex>=pow(16, 3) || pindex<0){
		r = -1;
		b = -1;
		g = -1;
		return;
	}
		
	r = pindex % 16;
	pindex /= 16;
	g = pindex%16;
	pindex /= 16;
	b = pindex % 16;

}


void reset_bitmask() {
	for(int i=0; i<bitmask.size();++i){
		bitmask[i] = 0;
	}
	
	for(int i=0; i<bitmask_pesi.size();++i){
		bitmask_pesi[i] = 0;
	}

}

vector<int> plot_bitmask(int n_match) {
	vector<int> id_img_match;
	float max_peso = 0;
	int id_max_peso = 0;
	cout<<"bitmask:"<<endl;
	for(int i=0; i<bitmask.size(); ++i){
		if(bitmask[i]>-1){
			float peso = bitmask_pesi[i];//(bitmask[i]);
			
			int min_match = min(npunti_immagini[i], n_match); 
			float p_match = (float)bitmask[i]/(float)min_match;
			if(p_match<1){
				cout<<"id:"<<indici_immagini[i]<<" n_match:"<<p_match<<"% "<<"index:"<<i<<" peso:"<<peso<<endl;
				//id_img_match.push_back(indici_immagini[i]);
				
				if(max_peso<peso) {
					max_peso=peso;
					id_max_peso = indici_immagini[i];
				}
			}
				
		}
	}
	
	id_img_match.push_back(id_max_peso);
	return id_img_match;
	
}



//ricerca nel mio vettore dei punti quali immagini hanno in comune i punti passati in l
//dopo di che ogni volta che ho un match incremento il rispettivo valore in bitmask
void ricerca_bitmask(const vector<list<id_iml> > &p_immagini, list<punto> punti) {

	int r,g,b;
	for(list<punto>::iterator it=punti.begin(); it!=punti.end(); ++it) {
		punto p = *it;
		if(p.r<0 || p.g<0 || p.b<0 || p.r>15 || p.g>15 || p.b>15) {
			cout<<"overflow"<<endl;
			return;
		}
		int pindex = get_pindex(p.r, p.g, p.b);
		list<id_iml> lista = p_immagini[pindex];
		//cout<<"count lista:"<<lista.size()<<endl;
		for(list<id_iml>::iterator ij=lista.begin(); ij!=lista.end(); ++ij) {
			
			id_iml img = *ij;
			int index_immagine = img.id_immagine;
			
			++bitmask[index_immagine];
					
		}
	}
}


struct el_cube{
	float peso;
	int id_linea;
};

float min(float f1, float f2){
	if(f2<f1)
		return f2;
	return f1;
}

void ricerca_cube(const vector<list<id_iml> > &p_immagini, el_cube cube[][16][16]) {
	float max_match=0;
	for(int r=0; r<16; ++r){
		for(int g=0; g<16; ++g){
			for(int b=0; b<16; ++b){
				if(cube[r][g][b].id_linea==-1) {
					max_match += cube[r][g][b].peso;
					
					int pindex = get_pindex(r, g, b);
					list<id_iml> lista = p_immagini[pindex];
					for(list<id_iml>::iterator ij=lista.begin(); ij!=lista.end(); ++ij) {
					
						id_iml img = *ij;
						int index_immagine = img.id_immagine;
											
						float min_peso = min(cube[r][g][b].peso, img.peso);
						
						bitmask_pesi[index_immagine] += min_peso;
						++bitmask[index_immagine];
						
					}
				}
			}
		}
	}
	
}





void reset_cube(el_cube cube[][16][16]){
	for(int x=0; x<16; ++x){
		for(int y=0; y<16; ++y){
			for(int z=0; z<16; ++z){
				cube[x][y][z].peso = 0;
				cube[x][y][z].id_linea = 0;
			}
		}
	}
}



vector<list<id_iml> > load_from_db() {
	
	list<id_iml> lista;
	vector<list<id_iml> > p_immagini(pow(16,3), lista);

	try{
		cout<<"Caricamento dati DB"<<endl;
		//carico i dati dal db
		connection C("dbname=postgres user=postgres password=segreto hostaddr=127.0.0.1 port=5432");
	
		string sql = "SELECT id_immagini,id_linee,r,g,b,peso FROM linee,immagini,possiede,punti ";
		sql += "WHERE id_immagini=fk_id_immagini AND id_linee=fk_id_linee and ";
		sql += "(id_punti=l1 OR id_punti=l2 OR id_punti=l3 OR id_punti=l4) ";
		sql+= "ORDER BY id_immagini, id_linee, id_punti;";
		nontransaction N(C);
		result R( N.exec( sql ));
		N.commit();
	
		
			
		cout<<"num di record caricati: "<<R.size()<<endl;
		
		int r,g,b,rp,gp,bp,id_immagine;
		int count_immagine=0;
		int id_immagine_vecchio;
		int n_linea=0;
		int id_linea_vecchio, id_linea;
		el_cube cube[16][16][16];
		float peso;
	
		punto p[4];
	
		reset_cube(cube);
	
	
		//carico tutto il db
		result::const_iterator c = R.begin();
		id_immagine_vecchio = c[0].as<int>(); 
		bitmask.push_back(0);
		bitmask_pesi.push_back(0);
		indici_immagini.push_back(id_immagine_vecchio);
		while (c != R.end()) {
			++n_linea;
			id_immagine = c[0].as<int>();
			id_linea = c[1].as<int>();
			peso = c[5].as<float>();
			for(int i=0; i<4; ++i){
				p[i].r = c[2].as<int>();
				p[i].g = c[3].as<int>();
				p[i].b = c[4].as<int>();
				++c;
			}

			if(id_immagine!=id_immagine_vecchio) {
				indici_immagini.push_back(id_immagine);
				bitmask.push_back(0);
				bitmask_pesi.push_back(0);
			}
				
			if(id_immagine!=id_immagine_vecchio) {
				int n_punti = 0;					
				for(int r=0; r<16; ++r){
					for(int g=0; g<16; ++g){
						for(int b=0; b<16; ++b){
							if(cube[r][g][b].id_linea>0) {
								++n_punti;
								id_iml c_id_iml;
								c_id_iml.id_immagine = count_immagine;
								c_id_iml.id_linea = cube[r][g][b].id_linea;
								c_id_iml.peso = cube[r][g][b].peso;
								p_immagini[get_pindex(r,g,b)].push_front(c_id_iml);
							}
						}
					}
				}
				npunti_immagini.push_back(n_punti);
				
				++count_immagine;
				reset_cube(cube);
			}
		
			id_immagine_vecchio = id_immagine;
		
			//ottengo la rasterizzazione della retta corrente
			list<punto> punti = bezier(p[0], p[1], p[2], p[3]);	
			for(list<punto>::iterator it=punti.begin(); it!=punti.end(); ++it) {
				punto p_app = *it;
				int r = p_app.r;
				int g = p_app.g;
				int b = p_app.b;
			
				cube[r][g][b].id_linea = n_linea;
				cube[r][g][b].peso = peso;
			}
		}
		int n_punti=0;	
		for(int r=0; r<16; ++r){
			for(int g=0; g<16; ++g){
				for(int b=0; b<16; ++b){
					if(cube[r][g][b].id_linea>0) {
						++n_punti;
						id_iml c_id_iml;
						c_id_iml.id_immagine = count_immagine;
						c_id_iml.id_linea = cube[r][g][b].id_linea;
						c_id_iml.peso = cube[r][g][b].peso;
						p_immagini[get_pindex(r,g,b)].push_front(c_id_iml);
					}
				}
			}
		}
		npunti_immagini.push_back(n_punti);
		
		C.disconnect();
		
	}catch (const std::exception &e){
		cerr << e.what() << endl;
	}
	
	return p_immagini;	
	
}



int main(int argc, char* argv[]) {
	string sql;
	
	list<id_iml> lista;
	
	//oggetto in cui ogni i-esimo elemento contiene gli indici delle immagini che hanno il punto identificato dall'indice i
	//ogni p_immagini[i] ha una lista contenente gli id delle immagini che hanno quel punto nella rasterizzazione
	vector<list<id_iml> > p_immagini = load_from_db();
	
	   
	
	
	
		
		
		/*
		//stampa struttura
		
		int n_l=0;
		int conta=0;
		for(int i=0; i<p_immagini.size(); ++i) {
			list<id_iml> l = p_immagini[i];
			int r,g,b;
			pindex_to_rgb(i, r,g,b);
			
			if(l.size()>0){
				++n_l;
				for(list<id_iml>::iterator it=l.begin(); it!=l.end(); ++it) {
					id_iml p = *it;
					if(2==p.id_immagine)
						cout<<"  id_immagine:"<<p.id_immagine<<" id_linea:"<<p.id_linea<<"peso"<<p.peso<<endl;
					if(p.id_immagine==0)
						conta++;
				}
				//cout<<endl;
			}
		}
		
		cout<<"conta "<<conta<<endl;
		*/
	
	while(true) {
		int id_ricerca_immagine=0;
		cout<<"inserisci l'id_immagine"<<endl;
		cin>>id_ricerca_immagine;
		
		if(id_ricerca_immagine==0)
			break;
		if(id_ricerca_immagine==-1) {
			cout<<"ricarico i dati"<<endl;
			bitmask.clear();
			bitmask_pesi.clear();
			indici_immagini.clear();
			npunti_immagini.clear();
			p_immagini = load_from_db();				
		}		
		else{
			try {
				float peso;
				el_cube cube[16][16][16];
	
				cout<<"Caricamento dati DB"<<endl;
				//carico i dati dal db
				connection C("dbname=postgres user=postgres password=segreto hostaddr=127.0.0.1 port=5432");
		
				//estraggo l'immagine che voglio cercare dal db
				string sql = "SELECT id_immagini,id_linee,r,g,b,peso FROM linee,immagini,possiede,punti ";
				sql += "WHERE id_immagini=fk_id_immagini AND id_linee=fk_id_linee and id_immagini=";
				sql += to_string(id_ricerca_immagine)+" and (id_punti=l1 OR id_punti=l2 OR id_punti=l3 OR id_punti=l4) ";
				sql += "ORDER BY id_immagini, id_linee, id_punti;";
				nontransaction N1(C);
				result R1( N1.exec( sql ));
				N1.commit();
		
				//vettore che contiene le linee dell'immagine che voglio cercare
				vector<linea> linee_ricerca;
				result::const_iterator c1=R1.begin();
				 
				while(c1!=R1.end()) {
					punto p[4];
					peso = c1[5].as<float>();	
					for(int i=0; i<4; ++i){
						p[i].r = c1[2].as<int>();
						p[i].g = c1[3].as<int>();
						p[i].b = c1[4].as<int>();
						++c1;
					}
			
					linea l(p[0], p[1], p[2], p[3], peso);
			
					linee_ricerca.push_back(l);
			
				}
		
				
		
				cout << "Dati caricati correttamente" << linee_ricerca.size()<<endl;
			
		
				//imposta il cubo per la ricerca
				reset_cube(cube);
				float m=0;
				for(int i=0; i<linee_ricerca.size(); ++i) {
					list<punto> punti = linee_ricerca[i].get_bezier();
					peso = linee_ricerca[i].get_peso();
					for(list<punto>::iterator it=punti.begin(); it!=punti.end(); ++it) {
						punto p = *it;
						cube[p.r][p.g][p.b].id_linea = -1;
						cube[p.r][p.g][p.b].peso = peso/punti.size();
					}
				}
				ricerca_cube(p_immagini, cube);
				
				float pe=0;
				int n_match=0;
				for(int r=0; r<16; ++r){
					for(int g=0; g<16; ++g){
						for(int b=0; b<16; ++b){
							if(cube[r][g][b].id_linea==-1) {
								pe += cube[r][g][b].peso;
								++n_match;
							}
						}
					}
				}
				
				cout<<"max peso: "<<pe<<" max match:"<<n_match<<endl;
				
				vector<int> id_img = plot_bitmask(n_match);
				reset_bitmask();
				
				//show result
				if(id_img.size()>0) {
					sql = "SELECT nome, id_immagini from immagini where id_immagini=";
					sql += to_string(id_ricerca_immagine);
					for(int i=0;i<id_img.size(); ++i) {
						sql += " or id_immagini=";
						sql += to_string(id_img[i]); 
					}
					cout<<sql<<endl;
					nontransaction N2(C);
					result R2( N2.exec( sql ));
					N2.commit();
					/////////////////////////////
						if(R2.size()==2){
						result::const_iterator it=R2.begin();
						string url1 = "../imgprof/";
						url1 += it[0].as<string>();
						string id1 =  it[1].as<string>();
					
						++it;
						string url2 = "../imgprof/";
						url2 += it[0].as<string>();
						string id2 =  it[1].as<string>();
					
						show_image(url1.c_str(), id1, url2.c_str(), id2);
					}
					
					/*
					for(result::const_iterator it=R2.begin(); it!=R2.end(); ++it) {
						string url = "../imgprof/";
						url += it[0].as<string>();
						cout<<url<<endl;
						show_image(url.c_str(), it[1].as<string>());
					}*/	
				}
				
				C.disconnect();
			}catch (const std::exception &e){
				cerr << e.what() << endl;
			}
		}//endif
	}

	return 0;
}




